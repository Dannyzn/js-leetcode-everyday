// 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。

// 每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

// 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue，

// 其中 queue[j] = [hj, kj]是队列中第j个人的属性（queue[0]是排在队列前面的人）。


// 示例1:

// 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
// 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
// 解释：
// 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
// 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
// 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
// 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
// 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
// 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
// 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。


// 题解:

// 此时会涉及到 两个变量  身高 h 和 k   
// 大致会分两步走:

// 第一步:  我们先按照身高 去处理 升序的
//    处理升序的时候  需要注意一下  子数组第一个参数 是否相同 
//        相同的情况下 需要根据子数组的 第二元素  进行 升序排列(正常的顺序)
//        不同的情况下  就是降序的处理

// 第二步  就是根据 第二个参数进行处理
//          简称插入的操作  根据子数组的第二参数 决定在原数组的中的 插入的位置

//  最后别忘了是 如何放到 queue 数组里面去的
//  需要 熟练  Array。prototype.splice(index, delete, addItem)



